## 04. 상태와 반응성 돌아보기

### 상태와 반응성
- **상태** : UI를 표현하고 렌더링하는 데 사용되는 데이터
- **반응성** : 상태가 변경될때 UI가 자동으로 업데이트 되는 원리

### 상태
- 특정 시점에 시스템이 가지는 조건이나 상황
- 상태를 기반으로 **현재 페이지의 모습**이 결정됨
  - ex. 인증 상태를 기반으로 홈페이지 || 로그인 페이지를 노출

#### 웹 애플리케이션의 2가지 상태
- **서버 상태**
  - API 응답값(DB의 원시 데이터)를 기반으로 비즈니스 로직에 따라 가공된 상태
  - ex. 유저의 정보, 게시글 목록
- **클라이언트 상태**
  - UI와 직접적인 상호작용을 위해 만들어진 상태
  - ex. 모달의 열림/닫힘

### 디자인 패턴
#### 디자인 패턴이란?
- **등장 배경**
  - 서버 상태 & 클라이언트 상태의 상호작용에서 복잡한 UI 로직과 데이터를 관리하기 위해
- 애플리케이션을 더 읽기 쉽고 유지보수하기 쉬운 구조로 설계하는 방법
  - 어떤 기능 단위로 구성할지
  - 구성 컴포넌트(= 기능 단위)는 어떤 역할을 책임질지

#### 디자인 패턴의 구성요소
- **View**
  - 데이터를 유저에게 보여주고, 유저의 입력을 시스템에 전달하는 가장 상위의 인터페이스
    - ex. UI를 화면에 렌더링, 유저의 입력(클릭, 스크롤 등)을 받아내기
  - React에서의 View 
    - JSX로 작성된 선언적인 UI 컴포넌트
- **Model**
  - 데이터를 담당
  - 프론트엔드에서의 모델 : 클라이언트 상태와 해당 상태를 관리하는 로직
    - ex. zustand
  - Model의 역할
    - 데이터 관리 (어떤 자료구조로? 어떻게 저장?)
    - 비즈니스 로직 (정책이나 규칙을 코드로 실행)
      - ex. 할인율을 적용하여 최종 가격 계산 / 재고 소진시 블럭 처리
- **Mediator**
  - "관심사의 분리 원칙"으로 인해 분리된 View와 Model의 동작을 연결해주는 역할
  - React에서의 이벤트 핸들러 함수 가 해당됨
- **React에서의 예시**
  - useState()와 같은 훅으로 "모델" 정의
  - 이벤트 핸들러 함수로 유저 입력에 반응하여 상태를 변경하는 로직으로 "중재자" 작성
  - JSX로 "뷰"를 반환

#### 관찰자 패턴
- 모델(데이터)가 변경되었을때, 자신에게 의존하는 객체(리스너들)에게 자동으로 알림을 보내 뷰를 업데이트하는 디자인 패턴
  - ex. 반응형 시스템 (개발자에게 UI 동기화 책임이 X - 상태가 바뀌면 자동으로 뷰가 변경)
- 상태와 뷰의 동기화 문제를 해결해줌!
- **발행-구독 패턴 모델** 이라고도 불림
  - **발행자**
    - 관찰의 대상이 되는 객체 
    - 자신의 상태 변화를 외부에 알려야하는 책임이 있음
  - **구독자**
    - 발행자의 상태 변화가 발생하면, 해당 변화 알림을 받고싶어하는 객체
    - 발행자를 구독하고 -> 발행자가 이벤트를 만들면 약속된 작업을 수행

### MVC 패턴 (Model - View - Controller)
- 애플리케이션을 모델, 뷰, 컨트롤러라는 세가지 독립적인 컴포넌트로 나누어서 설계하는 고전적인 아키텍처 패턴

### MVVM 패턴 (Model - View - ViewModel)
- 모던 프론트엔드 프레임워크에 가장 영향을 많이 미침
- View와 Model 사이를 ViewModel이 연결해준다는 로직
  - View는 ViewModel에 자신을 바인딩해두고, ViewModel의 상태가 바뀌면 자신의 모습을 자동으로 업데이트

#### 데이터바인딩
- View와 ViewModel의 데이터를 자동으로 동기화하는 메커니즘
- 2가지 방식
  - **단방향 바인딩**
    - 데이터가 ViewModel에서 View로 한쪽 방향으로만 흐름
    - ViewModel 상태가 변경되면 View 변경 BUT View가 변경되었다고 ViewModel이 변경되지는 X
    - React는 **단방향 바인딩을 기본적으로 채택한 라이브러리**
      - ex. useState()로 상태를 만들고, value 속성으로 UI(View)에 연결하고, onChange() 핸들러로 상태를 업데이트
  - **양방향 바인딩**
    - 데이터가 ViewModel / View 사이를 양쪽으로 자유롭게 흐름
    - ex. Vue.js


## 05. 개발 환경 돌아보기

### Node.js
- 서버와 같이 브라우저 밖에서 JS를 실행할 수 있게 해주는 실행 환경
  - ex. Next.js, Vite, Webpack, EsLint, Prettier, Jest, Storybook 등 빌드/개발 서버가 Node 위에서 돌아감
  - ex. 스크립트 자동화 (파일 읽고 쓰기, 폴더 정리, 코드 변환 등)
  - **내가 만드는 서비스는 브라우저에서 돌고, 해당 서비스를 만들고 빌드하는 도구는 Node에서 돈다!**

### NVM (= Node Version Manager)
- 1개의 컴퓨터에서 Node.js 버전을 여러개 설치해두고, 프로젝트마다 필요한 버전으로 쉽게 바꿔 쓸 수 있도록 해주는 도구
  - node -v 가 프로젝트마다 다르게
- .nvmrc 파일 생성 후, node 버전 적어두는 방식 (개발자들 간 버전 차이 방지)

### 패키지 매니저
- 프로젝트에서 쓰는 라이브러리(패키지)를 설치, 업데이트, 삭제하고 버전을 관리해주는 도구
- **대표 패키지 매니저**
  - npm, yarn, pnpm
- **핵심 파일 3가지**
  - package.json
    - 해당 프로젝트가 어떠한 라이브러리를 쓰는지 정보 제공
    - 스크립트 (dev, build, lint 등) 포함
  - node_modules/
    - 실제 설치된 라이브러리 폴더
    - 설치 결과물이 쌓이는 곳 (깃에는 보통 올리지 않음)
  - lock 파일
    - 팀원, CI, 컴퓨터 모두 똑같은 버전으로 설치되도록 고정
    - package-lock.json / yarn.lock / pnpm-locj.yaml

### 모노레포
- 여러개의 프로젝트를 하나의 레포에서 관리하는 방식
  - turborepo 와 같은 모노레포 툴을 사용
  - ex. 웹 앱, 어드민, 공통 UI 컴포넌트 라이브러리 등이 1개의 레포에서 관리
- **멀티레포** : 각 서비스마다 레포지토리가 따로 있는 형식
- **모노레포의 장점**
  - 공통 코드 재사용 쉬움
    - ex. ui, utils, types 등
  - 의존성, 버전 맞추기 용이
  - 변경사항 한번에 반영 가능
    - ex. ui 컴포넌트시, 모든 서비스에 일괄 적용
  - **분산 캐싱**
    - 캐시를 공유함으로써, 시간 단축 가능
      - ex. 팀원 A가 빌드와 테스트를 30초 동안하면, 팀원 B는 업로드한 캐시를 클라우드 서버에서 받아 1초만에 빌드와 테스트 완료
  - **작업 오케스트레이션**
    - 모듈 간 의존성 분석을 통해 병렬적으로 작업이 가능한 부분을 병렬로 실행해줌

### 코드 퀄리티 & 코드 포매팅
#### Linter
- 코드 퀄리티 검사기로서 미리 정의해둔 룰을 준수하지 않고 올바르지 않게 작성된 코드 감지
- 개발자가 커스터마이징한 규칙을 추가하기도 함

#### 포매터
- 코드의 형태를 일관되게 유지시켜주는 것 (Linter와 다르게 논리적 에러 확인 X)
- ex. Prettier

### React 개발 도구
#### 리액트 데브툴즈
- 리엑트 공식 문서에서 추천하는 도구
- 컴포넌트, props와 상태, 성능 이슈 확인 가능

#### 리액트 스캔
- 빈번한 컴포넌트 리렌더링 && 무거운 컴포넌트 해결에 도움
<br/>
<br/>
<br/>

# Part 02. 리액트 핵심 요소 깊게 돌아보기

## 06. JSX의 구성요소
### DSL
- Domain specific language : 특정 도메인의 문제를 해결할 목적으로 설계된 언어
- ex. CSS : '스타일링'이라는 명확한 목적을 가진 언어

#### 외부 DSL
- 독립적으로 설계된 문법과 파서 사용
- 별도의 인터프리터나 컴파일러 필요

#### 내부 DSL
- 기존 프로그래밍 언어의 문법과 기능을 확정한 언어
- ex. **JSX**
  - HTML의 태그와 유사하게 생긴 코드를 사용해 js 내부에서 UI 구조를 작성하는 용도로 만들어짐
  - JS에서 파생된 내부 DSL

### JSX를 구성하는 요소
#### JSXElements
- JSX에서 작성된 개별 UI 구성 요소 / 리액트 컴포넌트로 변환되어 렌더링 되는 기본 단위
- React에서는 **이름이 대문자로 시작하면 커스텀 컴포넌트 / 소문자로 시작하면 HTML 태그**로 간주

#### JSXFragment
- 부모 요소 없이 여러 자식 요소를 그룹화하고 싶을때 사용
```jsx
return (
  <>
    <li>First</li>
    <li>Second</li>
  </>
)
```

#### JSXElementName
- 컴포넌트의 이름을 지정하는 것 (유저 정의 리액트 컴포넌트 지정)

#### JSXAttributes
- JSX 엘리먼트에 추가 정보를 전달하는 키값 형태
- react 컴포넌트의 props로 전달
- 코드 중복을 줄이고 공통 속성 쉽게 사용 가능
- 속성의 우선순위에 주의해야하고, ...스프레드 연산자 이후에 선언된 속성이 이전 값을 뒤집어씌움

```jsx
<input
  type="text"
  placeholder="이름"
  className="input-field"
/>

// JSX를 속성값으로 넘기는 것도 가능
<Tooltip
  content={
    <>
      <h4>안녕</h4>
      <p>인사합니다.</p>
    </>
  }
>
```

### JSXChildren
- 위에 것들을 다 합쳐서, JSX의 children을 가리키는 표현
