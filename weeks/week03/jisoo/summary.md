## 07. JSX 핵심 문법과 자바스크립트 변환 돌아보기
- JSX가 일반 js로 컴파일 되는 방법 / 바벨 & ESBuild의 역할

### JSX 변환하기
#### 자동 런타임
- React 17버전부터 자동 런타임을 도입
  - 더이상 import React from 'react';를 적을 필요 X
  - 트랜스파일러는 React.createElement() 대신 리액트 패키지에 내장된 별도의 함수를 자동으로 import해서 사용

#### 변환 도구
- 바벨
- SWC
  - 싱글 스레드에서 바벨보다 20배가량 빠른 속도로 변환 작업을 수행
  - Next.js는 SWC를 기본 컴파일러로 사용!
- ESBuild
  - 별도의 설정 없이도 기본적으로 JSX를 인식

### React.createElement && 리액트 엘리먼트 && 가상 DOM
- React.createElemet()와 jsx()는 리액트 엘리먼트 (= js 불변 객체)를 반환
  - 리액트 엘리먼트 = 가상 DOM 구조의 일 부분 / JSX로 표현된 정보를 가진 불변 객체
- 이러한 객체 변환을 위해 React는 UI를 선언적이고 효율적으로 다룰 수 있음
  - 불변 객체를 메모리 상에서 비교하고, 필요 부분만 실제 DOM에 반영하니까


## 08. 리액트 재조정과 키 프롭스 돌아보기
### React의 렌더링 프로세스
  - 트리거 (렌더링 시작) -> 렌더 (컴포넌트를 실행) -> 커밋 (실제 DOM을 업데이트)

#### 렌더링과 가상 DOM을 돌아봐야 하는 이유
- 리액트의 렌더링 로직은 함수의 실행이 외부에 영향을 끼치지 않는 순수 함수처럼 동작해야함
- 불필요한 렌더링을 방지해야함 (ex. memo(), useCallback(), useMemo() 사용)
- 리스트 렌더링 시 발생가능한 상태 관리 이슈나 비효울적인 업데이트를 방지

#### React Component란
- React element tree를 반환 타입으로 가지는 클래스 / 함수
  - ex. 함수형 컴포넌트의 경우, 함수의 반환 값 출력
  - ex. 클래스 컴포넌트의 경우, 렌더 메서드의 반환값 출력

#### React Element란
- React에게 어떤 것을 화면에 보여주고 싶은지를 전달하는 단순 객체

#### React 인스턴스란
- React가 애플리케이션을 실제로 구동할 때 각 컴포넌트의 상태를 추적하고 관리하는데 사용되는 클래스 컴포넌트의 인스턴스
 - ex. useRef() 훅을 사용하여, 인스턴스가 비슷한 역할 ( = 변수처럼 값을 저장하고 유지할 수 있는 공간) 생성 가능

 #### 렌더링 과정
 - **렌더링** : 컴포넌트 함수를 호출하여 리액트 엘리먼트를 생성하는 과정
   - UI가 앞으로 어떻게 뵐지 계산하는 과정
   - 실제 DOM 조작 X하고, 메모리 상에서 새로운 가상 DOM을 계산
     - 이후, React에서 이전/새로운 가상 DOM 비교해서 변경 필요 부분 찾는것
- **Step 1 : 트리거**
  - 최초 렌더링 : root.rendet() 호출할때 트리거
  - 리렌더링 : useState()의 상태 설정 함수 / 클래스 컴포넌트인 경우에는 this.setState() 호출을 통해 트리거

- **Step 2 : 렌더**
  - 렌더 : 마운트 && 언마운트는 컴포넌트가 렌더링하는 시작과 끝을 담당
  - 리렌더링 : 이미 마운트된 컴포넌트의 함수를 다시 호출하여 새로운 리엑트 엘리먼트 트리 생성

- **Step 3. 커밋**
  - 변경된 가상 DOM의 결과를 실제 DOM에 적용하고 화면에 반영하는 단계

### 재조정 과정
- 이전 / 새로운 가상 DOM 비굑하고 실제 변경 부분만 찾아서 업데아트 하는거
- **key** 와 **type**이 모두 일치해야만 React는 **동일 element**라고 판단
  - 동일인 경우 : 기존 DOM 노드 재사용하여 프롭스만 업데이트
  - 다른 경우 : 삭제하고, 새로운 엘리먼트를 위한 파이버 생성
  - **따라서 key props가 중요한것!**

### 디핑 알고리즘
- 두 트리의 차이범을 효율적으로 찾아내는 알고리즘
- 이전/새 가상 DOM을 비교해 실제 DOM에 최소 변경만 반영
- 핵심 규칙:
  - 타입이 다르면 노드와 하위 트리를 통째로 교체
  - 타입이 같으면 props만 갱신하고 children을 재귀적으로 비교
  - 리스트는 안정적인 key로 매칭하여 재사용

### 얇은 비교 (Shallow Comparison)
- "바로 아래 1단계 속성만” 참조 / 중첩된 내부 객체까지 내려가서 비교 X
- 중첩 객체 내부 값만 바뀌면 감지 못함
- ex. React.memo

## 09. 리액트 렌더링 규칙 돌아보기
### 렌더링 조건
- **최조 렌더링**
- **상태 변경 :** ex. useState()
- **부모 컴포넌트의 리렌더링 :** 자식도 함께 렌더링됨
  - 일반 자식 컴포넌트 : 항상 리렌더링
  - children prop으로 전달된 컴포넌트 : APP이 리렌더링 되지 않는 한, children 참조는 그대로 유지 (리렌더링 X)
- **context 변경 :** useContext() 통해 구독하는 값 변경 시

### 불변성
- JSX에 전달된 객체나 배열을 직접 수정 X
- 항상 새로운 객체나 배열을 생성하여 상태 변화 표현!
  - 이유: 얕은 비교로 변경 감지 → 리렌더 최적화, 예측 가능성 향상
  - 원칙: 제자리 수정 금지, 변경 시 새 참조 생성
  - 객체 예시:
    ```tsx
    // ❌ 직접 변경
    setUser(u => { u.name = 'Jisoo'; return u; });
    // ✅ 새 객체
    setUser(u => ({ ...u, name: 'Jisoo' }));
    ```
  - 배열 예시:
    ```tsx
    // 추가
    setItems(arr => [...arr, item]);
    // 수정
    setItems(arr => arr.map(it => it.id === id ? { ...it, done: true } : it));
    // 삭제
    setItems(arr => arr.filter(it => it.id !== id));
    ```