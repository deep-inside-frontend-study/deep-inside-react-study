# chapter 07. JSX 핵심 문법과 자바스크립트 변환 돌아보기

## 7.1 JSX 핵심 문법과 자바스크립트 변환 돌아봐야 하는 이유

- JSX는 자바스크립트 코드 안에 HTML과 유사한 문법을 사용할 수 있게 해주는 문법 확장이다. JSX를 이해하면 컴포넌트를 더 직관적으로 작성할 수 있으며, 자바스크립트로 변환되는 과정을 이해함으로써 성능 최적화와 디버깅에 도움이 된다.

## 7.2 JSX 변환하기

- JSX는 브라우저가 직접 이해할 수 없기 때문에, Babel과 같은 도구를 사용하여 자바스크립트 코드로 변환해야 한다. 예를 들어, `<div>Hello, World!</div>`라는 JSX 코드는 `React.createElement('div', null, 'Hello, World!')`로 변환된다.

### 7.2.1 자동 런타임이란?

- React.createElement 호출할때 3가지 인자를 받는다.
  - 첫번째: 태그이름 또는 컴포넌트
  - 두번째: props 객체
  - 세번째: 자식노드들

- React 17에 도입된 자동 런타임은 JSX 변환 시 React를 명시적으로 import하지 않아도 되는 기능이다. Babel 설정에서 `@babel/preset-react`의 `runtime` 옵션을 `automatic`으로 설정하면, JSX가 자동으로 필요한 React 함수를 가져오도록 변환된다. 이를 통해 코드가 더 간결해지고, 불필요한 import 문을 줄일 수 있다.

- React.createContext()와 같은 구문으로 리액트 내부 API를 사용할 때는 여전히 React를 import 해야하고, react/jsx-runtime은 JSX 변환을 위한 엔트리포인트 역할을 한다.

### 7.2.3 SWC로 JSX 변환해보기

- SWC는 빠른 속도의 Rust로 작성된 자바스크립트/타입스크립트 컴파일러로, Babel과 유사한 기능을 제공한다. SWC를 사용하여 JSX를 변환하려면, `@swc/core` 패키지를 설치하고, SWC 설정 파일에서 `jsc.parser.syntax`를 `ecmascript`로 설정한 후, `jsc.transform.react` 옵션을 활성화하면 된다. SWC는 babel보다 2배 이상 빠른 변환 속도를 제공한다.

### 7.2.4 ESbuild로 JSX 변환해보기

- ESbuild는 Go 언어로 작성된 빠른 자바스크립트 번들러이자 컴파일러로, JSX 변환 기능도 포함하고 있다. ESbuild를 사용하여 JSX를 변환하려면, `esbuild` 패키지를 설치하고, 명령줄에서 `--bundle --outfile=dist/bundle.js`옵션을 사용하여 JSX 파일을 처리하면 된다. ESbuild는 매우 빠른 빌드 속도를 제공한다.

### 7.2.5 React.createElement와 리액트 엔리먼트 그리고 가상 DOM

- React.createElement는 JSX를 자바스크립트로 변환할 때 사용되는 함수로, 리액트 엘리먼트를 생성한다. 리액트 엘리먼트는 가상 DOM의 기본 단위로, 실제 DOM과는 별개로 메모리 상에 존재한다.

```
{
  '$$typeof': Symbol(react.element),
  type: 'div',
  key: null,
  ref: null,
  props: { children: 'Hello, World!' , id: 'my-div' children: [ ... ] },
  _owner: null,
  _store: {}
}
```

- 이 불변객체의 속성을 보면, type은 내부 식별용 속성으로 리액트 내부에서는 심볼을 사용하여 정의되어있다. props는 컴포넌트에 전달되는 속성들을 담고 있으며, key와 ref은 리액트에서 리스트 랜더링이나 참조에 사용되는 속성이고, children은 자식 노드들을 나타낸다. 리액트는 이러한 JSX정보를 가지고 있는 불변객체를 사용해서 객체 트리를 구성하고, 이를 기반으로 실제 DOM과 비교하여 변경사항을 효율적으로 업데이트한다.

## 7.3 JSX의 핵심 문법 돌아보기

- 템플릿 리터럴, 스타일링, 이벤트 처리, 조건부 렌더링까지 다양한 JSX 문법을 살펴본다.

### 7.3.1 템플릿 리터럴과 테그트 템플릿 돌아보기

- es6에서 소개된 템플릿 리터럴은 백틱(``)으로 감싸진 문자열로, 변수와 표현식을 쉽게 삽입할 수 있다. 테그드 템플릿은 함수와 함께 사용되어, 템플릿 리터럴의 각 부분을 처리할 수 있다. JSX에서는 템플릿 리터럴을 사용하여 동적인 문자열을 생성하거나, 스타일링에 활용할 수 있다.

- 직접 스타일 컴포넌트 만드는 예시

```jsx
const SeunghoStyled = {
  div: (css, ...args) => {
    const styleString = css.reduce((acc, curr, index) => {
      return acc + curr + (args[index] ?? "");
    }, "");
    const styleObj = styleString
      .split(";")
      .filter((rule) => rule.trim() !== "")
      .reduce((acc, rule) => {
        const sep = rule.indexOf(":");
        if (sep === -1) return acc;
        const key = rule.slice(0, sep).trim();
        const value = rule.slice(sep + 1).trim();
        const jsKey = key.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
        acc[jsKey] = value;
        return acc;
      }, {});
    return ({ style, ...props }) => <div style={{ ...styleObj, ...style }} {...props} />;
  },
};
const RedDiv = SeunghoStyled.div`
  background-color: red;
  color: white;
  padding: 10px;
`;

export default function Example() {
  return <RedDiv>이것은 빨간색 배경의 div입니다.</RedDiv>;
}
```

### 7.3.2 JSX VS 템플릿 리터럴

- JSX와 템플릿 리터럴은 모두 UI를 구성하는 데 사용되지만, JSX는 컴포넌트 기반의 구조를 지원하며, 자바스크립트 표현식을 직접 삽입할 수 있다. 반면에 템플릿 리터럴은 문자열 조작에 더 적합하며, HTML 구조를 표현하는 데는 한계가 있다. 따라서 복잡한 UI를 구성할 때는 JSX가 더욱 선언적으로 작성할 수 있다.

### 7.3.3 합성 이벤트

- 합성 이벤트는 리액트가 제공하는 이벤트 시스템으로, 브라우저의 기본 이벤트를 래핑하여 일관된 인터페이스를 제공한다. 합성 이벤트는 브라우저 간의 호환성을 보장하며, 이벤트 풀링을 통해 성능을 최적화한다.

- 이전에는 브라우저 종류에 따라 DOM 이벤트를 다르게 처리해야 했지만, 합성 이벤트를 사용하면 리액트가 이를 추상화하여 개발자가 일관된 방식으로 이벤트를 처리할 수 있다.

- 드래그앤드롭 이벤트 핸들러 정의

```jsx
 function DragDrop() {
    const handleDragStart = (e: React.DragEvent<HTMLDivElement>) => {
      e.dataTransfer.setData("text/plain", (e.target as HTMLDivElement).id);

      e.dataTransfer.effectAllowed = "move";

      const dragIcon = document.createElement("img");
      dragIcon.src = 'icon.png';
      e.dataTransfer.setDragImage(dragIcon, 0, 0);};

    const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    };

    const handleDrop = (e) => {
      e.preventDefault();
      const data = e.dataTransfer.getData("text/plain");
      // setItem(previousItem => previousItem + data);
    };

    const handleDragEnter = (e: React.DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      // 드래그 진입 시 처리할 로직
      e.currentTarget.classList.add("drag-over");
    };

    const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
      // 드래그 종료 시 처리할 로직
      e.currentTarget.classList.remove("drag-over");
    };

    return (
      <div id='container'>
        <div
          id='draggable-item'
          draggable
          onDragStart={handleDragStart}
        >
          드래그하세요
        </div>
        <div
          id='drop-zone'
          onDragOver={handleDragOver}
          onDrop={handleDrop}
          onDragEnter={handleDragEnter}
          onDragLeave={handleDragLeave}
          style={{ width: '200px', height: '200px', backgroundColor: 'lightgray' }}
        >
          여기에 드롭하세요
        </div>
      </div>
    );
 }
```

- 리액트는 단일 이벤트 리스너로 관리하여 성능을 최적화한다. 예를 들어, 여러 버튼에 각각 클릭 이벤트 리스너를 추가하는 대신, 리액트는 최상위 요소에 하나의 클릭 이벤트 리스너를 등록하고, 이벤트 버블링을 통해 하위 요소의 클릭 이벤트를 처리한다. 이를 통해 메모리 사용량을 줄이고, 이벤트 처리 속도를 향상시킨다.
  ex) button -> div -> body -> HTML -> document

- 16버전까지는 이벤트 리스너가 부착되는 최상위 레벨이 document였지만, 17버전부터는 해당 루트 컨테이너로 변경되었다.

- 16버전까지는 성능을 최적화하기 위해 합성 이벤트 객체를 재사용하는 이벤트 풀링(event pooling) 기법을 사용했지만, 17버전부터는 이벤트 풀링이 제거되었다. 이제 합성 이벤트 객체는 매번 새로 생성되며, 이벤트 핸들러 내에서 비동기 작업을 수행할 때도 안전하게 사용할 수 있다.

### 7.3.4 단일 루트 엘리먼트

- 리액트 컴포넌트는 하나의 루트 엘리먼트만 반환해야 한다. 여러 개의 형제 엘리먼트를 반환하려면, `<div>`와 같은 래퍼 엘리먼트를 사용하거나, `<React.Fragment>` 또는 빈 태그(`<> </>`)를 사용하여 감싸야 한다. 이렇게 하면 가상 DOM 트리가 올바르게 구성되고, 렌더링 과정에서 문제가 발생하지 않는다. 이유는 리액트가 컴포넌트의 반환값을 단일 객체로 기대하기 때문이다. 리액트 컴포넌트는 하나의 리액트 엘리먼트 객체를 반환해야 하며, 여러 개의 형제 엘리먼트를 반환하면 어떤 엘리먼트가 루트인지 알 수 없게 된다. jsxs안에 jsxs가 들어가는 형태는 올 수 없다.

### 7.3.5 삼항 연산자와 &&

- JSX에서 조건부 렌더링을 구현할 때 삼항 연산자(`condition ? trueExpression : falseExpression`)와 논리 AND 연산자(`condition && expression`)를 자주 사용한다. 삼항 연산자는 조건에 따라 두 가지 다른 엘리먼트를 렌더링할 때 유용하며, 논리 AND 연산자는 조건이 참일 때만 특정 엘리먼트를 렌더링할 때 편리하다.

- JSX 자식으로 false, null, undefined, true는 렌더링되지 않는다. 따라서 && 연산자를 사용할 때 조건이 거짓이면 아무것도 렌더링되지 않는다. 하지만 NaN은 number 타입이므로 JSX에서 자식으로 사용하면 "NaN" 문자열로 렌더링된다. 따라서 NaN을 조건부 렌더링에 사용해서 가드해주는게 좋다.

# chapter 08. 리액트 재조정과 키 프롭스 돌아보기

## 8.1 랜더링과 가상 DOM 돌아봐야하는 이유

- 리액트의 랜더링 과정과 가상 DOM의 역할을 이해하면, 성능 최적화와 효율적인 UI 업데이트 방법을 알 수 있다. 가상 DOM은 실제 DOM과 비교하여 변경사항만 업데이트하므로, 불필요한 렌더링을 줄이고 애플리케이션의 반응성을 향상시킨다.

## 8.2 리액트 컴포넌트와 인스턴스

- 리액트 컴포넌트는 UI를 구성하는 기본 단위로, 함수형 컴포넌트와 클래스형 컴포넌트로 나뉜다. 컴포넌트 인스턴스는 컴포넌트가 렌더링될 때 생성되는 객체로, 상태(state)와 생명주기 메서드(lifecycle methods)를 관리한다. 함수형 컴포넌트는 상태와 생명주기 관리를 위해 훅(hooks)을 사용하며, 클래스형 컴포넌트는 `this.state`와 생명주기 메서드를 통해 이를 처리한다.

- 리액트 엘리먼트는 인스턴스가 아니다. 리액트 엘리먼트는 컴포넌트 인스턴스를 생성하기 위한 청사진(설계도) 역할을 한다. 리액트 엘리먼트는 불변 객체로, 컴포넌트의 타입, 속성(props), 자식(children) 등의 정보를 담고 있다. 리액트는 이 엘리먼트를 기반으로 컴포넌트 인스턴스를 생성하고, 이를 통해 UI를 렌더링한다.

- 함수형 컴포넌트는 단순히 props를 받아 UI를 반환하는 역할을 하며, 상태 관리와 생명주기 메서드는 훅을 통해 처리된다. 반면에 클래스형 컴포넌트는 `this.state`를 사용하여 상태를 관리하고, `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`와 같은 생명주기 메서드를 통해 컴포넌트의 생명주기를 제어한다.

- 함수형 컴포넌트는 파이버 노드를 통해 상태와 훅 정보를 관리한다. 파이버 노드는 리액트의 내부 데이터 구조로, 각 컴포넌트 인스턴스에 대한 정보를 담고 있다. 함수형 컴포넌트가 렌더링될 때, 리액트는 해당 컴포넌트의 파이버 노드를 생성하고, 훅 호출 순서와 상태 값을 추적하여 관리한다. 이를 통해 함수형 컴포넌트도 상태와 생명주기 관리를 효율적으로 수행할 수 있다.

- 19버전 이전까지는 ref를 통해 클래스형 컴포넌트 인스턴스에 접근할 수 있었지만, 함수형 컴포넌트는 인스턴스가 없기 때문에 ref로 접근할 수 없다. 대신, forwardRef라는 별도 훅을 통해서 ref를 전달할 수 있었다.

## 8.3 랜더링과 리랜더링

- 랜더링 과정은 전체적으로 UI가 앞으로 어떻게 그려지는지 계산하는 단계이다. 리액트는 컴포넌트의 반환값(리액트 엘리먼트)을 기반으로 가상 DOM 트리를 생성한다.

- 실제 DOM을 업데이트 하는 과정은 커밋(commit) 단계에서 이루어진다. 리액트는 렌더링 단계에서 가상 DOM을 생성하고, 이전 가상 DOM과 새로운 가상 DOM을 비교하여 변경사항을 식별한다. 그런 다음, 커밋 단계에서 실제 DOM에 변경사항을 적용한다.

- 랜더링 과정은 트리거, 랜더, 커밋 3단계로 나눈다.
  - 트리거: 상태 변경, props 변경, 부모 컴포넌트 리랜더링 등으로 인해 랜더링이 시작되는 단계이다.
  - 랜더: 컴포넌트의 반환값을 기반으로 가상 DOM 트리를 생성하는 단계이다. 리액트 18부터 동시성 렌더링이 도입되어, 이 단계에서 작업을 일시 중단하고 우선순위가 높은 작업을 먼저 처리할 수 있다.
    따라서 랜더 단계는 더 이상 단일 작업이 아니며, 여러 번에 걸쳐 나누어질 수 있다.
  - 커밋: 변경사항을 실제 DOM에 적용하는 단계이다. 이 단계에서는 식별된 변경사항을 기반으로 실제 DOM을 업데이트한다.

- 리랜더링은 컴포넌트가 이미 렌더링된 후에 다시 컴포넌트를 렌더링되는 과정을 의미한다. 따라서 새로운 트리를 생성하고, 이전에 랜더링된 트리와 비교하여 변경사항을 식별한 후, 실제 DOM에 적용하는 과정을 포함한다.

- 커밋 단계는 리액트의 렌더링 과정에서 실제 DOM에 변경사항을 적용하는 단계이다. 이전 트리와 새 트리를 비교(재조정, reconcile)해서 변경사항을 식별하는 작업은 렌더 단계에서 수행되고, 커밋 단계는 그 결과를 바탕으로 DOM 변경/레이아웃 이펙트 등을 반영한다. 커밋 단계는 동기적으로 수행되며, 리액트 18의 동시성 렌더링은 주로 "렌더 단계"를 쪼개서 진행할 수 있게 해주는 것이라 커밋 자체와는 성격이 다르다.

- 언마운트 단계는 컴포넌트가 DOM에서 제거될 때 발생하는 과정이다. 이 단계에서는 컴포넌트의 생명주기 메서드인 `componentWillUnmount`가 호출되며, 이벤트 리스너 제거, 소켓 정리 등과 같은 정리 작업이 수행된다. 언마운트 단계는 커밋 단계와 밀접하게 연관되어 있으며, 컴포넌트가 더 이상 필요하지 않을 때 리소스를 해제하는 역할을 한다.

- 랜더단계: 실행시점은 초기랜더링 또는 리랜더링이 트리거 될때이고, 주요 작업은 컴포넌트의 반환값을 기반으로 가상 DOM 트리를 생성하는 것이다. 이 단계에서는 리액트는 컴포넌트의 상태와 props를 기반으로 새로운 가상 DOM 트리를 생성하고, 이전 가상 DOM 트리와 비교하여 변경사항을 식별한다.

- 커밋단계: 실행시점은 랜더단계가 완료된 후이고, 주요 작업은 변경사항을 실제 DOM에 적용하는 것이다. 이 단계에서는 리액트는 식별된 변경사항을 기반으로 실제 DOM을 업데이트하며, 필요한 경우 레이아웃 이펙트도 반영한다.

## 8.4 재조정 과정

- 재조정 과정은 리액트가 이전 가상 DOM 트리와 새로운 가상 DOM 트리를 비교하여 변경사항을 식별하는 과정이다. 이 과정에서 리액트는 각 노드의 타입과 키(key)를 비교하여, 어떤 노드가 변경되었는지, 추가되었는지, 삭제되었는지를 결정한다

- 리액트는 재조정 과정에서 다음과 같은 규칙을 따른다:
  - 동일한 타입의 노드는 재사용된다.
  - 타입이 달라지면 그 노드의 하위 트리도 그대로 재사용하지 않고, 기존 것은 언마운트되고 새로 마운트되는 쪽에 가깝다(상태도 초기화됨).
  - 비교는 "같은 레벨(같은 부모 아래의 형제)"끼리 이뤄진다. 다른 레벨로 이동한 노드는 같은 노드로 추적되지 않는다.
  - 리스트의 경우, 키를 기준으로 매칭하여 최소한의 변경을 계산한다.
  - 키가 없으면 "순서"가 식별자 역할을 하므로, 중간 삽입/삭제/정렬 변경이 잦을 때는 잘못된 재사용(의도치 않은 state 이동)이 발생하기 쉽다.

- 파이버(fiber)는 리액트의 내부 데이터 아키텍처로, 각 컴포넌트 인스턴스에 대한 정보를 담고 있다. 파이버는 재조정 과정에서 중요한 역할을 하며, 이전 가상 DOM 트리와 새로운 가상 DOM 트리를 비교하는 데 사용된다. 파이버는 각 노드가 어떤 변경, 관계 등을 추적할 수 있도록 정보를 저장한다.

- 리액트는 재조정 과정(자식재조정)에서 단일 엘리먼트인 경우 다음과 같은 단계를 거친다
  - 이전 파이버 트리와 새로운 반환값(리액트 엘리먼트)을 비교한다.
  - 단일 엘리먼트인 경우, 타입과 키를 비교하여 재사용 여부를 결정한다. 재사용할 수 없으면 새 파이버 노드를 생성한다.
  - 변경사항을 식별한 후, 필요한 파이버 노드를 생성하거나 재사용한다.

- 재조정 과정 배열/이터러블에 과정은 다음과 같다
  - 이전 자식 파이버들을 모두 순회하며 인덱스 기반으로 Map 자료구조를 만든다.
  - 새로운 자식 엘리먼트들을 순회하며, 이전 파이버와 비교를 시도한다.
  - 인덱스 기준 비교에서 타입/키가 일치하면 재사용하고, 일치하지 않으면 Map에서 키 기준으로 찾아본다.
  - 키 기준 비교에서도 일치하는게 없으면 새 파이버 노드를 만든다.
  - 새로운 자식 엘리먼트 순회가 끝난 후, 이전 파이버들 중에서 사용되지 않은 것들은 언마운트 처리한다.

### beginWork / completeWork 전체 흐름 (렌더 단계 DFS 순회)

- `beginWork`/`completeWork`는 "특정 종류의 파이버"가 아니라, 렌더(재조정) 단계에서 파이버 트리를 순회할 때 호출되는 함수(처리 단계)이다.
- 리액트는 이미 커밋된 트리(`current`)와 작업 중 트리(`workInProgress`, WIP)를 번갈아 사용한다(더블 버퍼링). 업데이트가 시작되면 WIP 트리를 만들어(또는 재사용해) 렌더 단계에서 계산을 진행한다.
- 전체 흐름
  - 내려갈 때: `beginWork(current, workInProgress, lanes)`로 "자식 만들기/비교"를 하고 다음으로 갈 `child`를 고른다.
  - 올라올 때: `completeWork(current, workInProgress, lanes)`로 "DOM 업데이트 준비/플래그 버블링"을 하고 `sibling` 또는 `return(parent)`로 이동한다.
  - 렌더 단계가 끝나면 커밋 단계에서 플래그를 보고 실제 DOM 삽입/수정/삭제 + layout effect 실행이 이뤄진다.

- `beginWork(current, workInProgress, lanes)`
  - 트리를 "아래로 내려가면서" 현재 파이버를 처리한다.
  - DFS로 내려가며 비교(current) + 새 트리 작성(WIP) + 우선순위 판단(lanes) 을 한 번에 처리하려고 저 형태로 되어 있다.
  - 함수/클래스 컴포넌트라면 `render`(또는 hooks 렌더)를 실행해서 nextChildren(리액트 엘리먼트들)을 얻는다.
  - 그 nextChildren을 기준으로 자식 파이버들을 재조정(reconcileChildren) 해서 WIP의 `child`/`sibling` 체인을 만든다.
  - 변경이 없으면 스킵해서 아래 서브트리를 다시 만들지 않을 수도 있다.

- `completeWork(current, workInProgress, lanes)`
  - 모든 자식 처리가 끝난 뒤 "위로 올라오면서(unwind)" 현재 파이버를 마무리한다.
  - Host 컴포넌트(`<div>` 같은 DOM 노드)라면 DOM 인스턴스 생성/업데이트 정보를 준비하고, 커밋 단계에서 실제로 반영될 수 있게 플래그를 남긴다.
  - 자식들에서 올라온 변경 플래그(Placement/Update/Deletion 등)를 부모로 버블링한다.

### 이팩트 리스트를 완성 후 커밋 단계에서 실제 DOM에 반영

- 렌더 단계에서 `completeWork`가 호출될 때, 각 파이버 노드에 변경 플래그(Placement, Update, Deletion 등)를 설정한다.
- 또한, 변경이 필요한 파이버 노드들을 연결하여 이팩트 리스트(effect list)를 완성한다. 이 이팩트 리스트는 변경이 필요한 노드들을 순서대로 나열한 연결 리스트이다.
- 커밋 단계에서는 이 이팩트 리스트를 순회하며, 각 노드의 플래그에 따라 실제 DOM에 변경사항을 적용한다

## 8.5 얕은 비교와 렌더링 최적화

- "리액트가 가상 DOM 트리 전체를 얕은 비교로 비교한다"라고 말하면 오해의 소지가 있다.
  - 재조정(reconcile)은 기본적으로 엘리먼트의 타입(type)과 key를 기준으로 "같은 것으로 볼지/교체할지"를 결정하는 규칙에 가깝고, 임의의 객체를 깊게/얕게 비교해서 트리를 통째로 diff하는 방식은 아니다.

- 얕은 비교(shallow compare)가 직접적으로 등장하는 곳은 주로 "렌더 스킵(bail out)" 최적화다.
  - `React.memo`/`PureComponent`는 기본적으로 props를 얕은 비교로 비교해서, props가 같으면 하위 렌더를 생략할 수 있다(커스텀 비교 함수도 가능).
  - 훅의 dependency array(`useMemo`, `useCallback`, `useEffect`)는 각 의존성을 `Object.is`로 비교하는 "참조 기반 비교"이기 때문에, 객체/배열/함수를 매 렌더마다 새로 만들면 의도치 않게 다시 실행/재계산된다.

- 결론: 렌더링 최적화를 하려면 "깊은 값이 같더라도 새 객체를 만들면 달라진 것으로 보일 수 있다"는 점을 이해하고, 필요할 때만 `memo`/`useMemo`/`useCallback`로 참조 안정성을 맞추는 것이 중요하다.

## 8.6 키(key) 프롭스와 리스트 랜더링

- 키(key) 프롭스는 리액트에서 리스트를 렌더링할 때 각 항목을 고유하게 식별하기 위해 사용되는 속성이다. 키는 리액트가 재조정 과정에서 각 항목의 변경사항을 효율적으로 추적하고, 최소한의 업데이트로 실제 DOM을 변경할 수 있도록 도와준다.

## 8.7 키 프롭스와 메모이제이션

- 키 프롭스를 사용하면 리액트는 다음과 같은 이점을 얻을 수 있다:
  - 최소한의 변경사항 적용: 키를 사용하여 항목을 식별함으로써, 리액트는 변경된 항목만 업데이트하고, 나머지 항목은 재사용할 수 있다. 이를 통해 불필요한 렌더링을 줄이고 성능을 향상시킨다.
  - 안정적인 항목 추적: 키는 항목의 순서가 변경되더라도 각 항목을 안정적으로 추적할 수 있게 해준다. 예를 들어, 리스트에서 항목이 추가되거나 삭제될 때도, 리액트는 키를 기준으로 항목을 올바르게 매칭할 수 있다.
  - 메모이제이션과의 시너지: 키 프롭스는 `React.memo`와 같은 메모이제이션 기법과 함께 사용될 때 더욱 효과적이다. 메모이제이션은 컴포넌트의 렌더링 결과를 캐싱하여, 동일한 props로 다시 렌더링할 때 이전 결과를 재사용한다. 키 프롭스가 올바르게 설정되어 있으면, 리액트는 메모이제이션된 컴포넌트를 효율적으로 관리할 수 있다.
  - 하지만 React.memo()도 키를 잘못 사용할 시 올바르게 동작하지 않을 수 있다. 키가 바뀌면 컴포넌트 인스턴스 자체가 바뀌기 때문에 메모이제이션된 결과를 재사용할 수 없기 때문이다.

# chapter 09. 리액트 랜더링 규칙 돌아보기

## 9.1 리액트 랜더링 규칙 돌아봐야 하는 이유

- 리액트의 랜더링 규칙을 이해하면, 컴포넌트의 상태 관리와 렌더링 최적화에 도움이 된다. 이를 통해 불필요한 렌더링을 줄이고, 애플리케이션의 성능을 향상시킬 수 있다.

## 9.2 리액트 랜더링 조건

- 리액트 컴포넌트는 다음과 같은 조건에서 랜더링된다:
  - 초기 랜더링: 컴포넌트가 처음으로 마운트될 때 랜더링된다.
  - 상태 변경: 컴포넌트의 상태(state)가 변경될 때 랜더링된다.
  - 부모 컴포넌트 랜더링: 부모 컴포넌트가 랜더링될 때 자식 컴포넌트도 함께 랜더링된다
  - 컨텍스트 변경: 컴포넌트가 구독하고 있는 컨텍스트(Context)가 변경될 때 랜더링된다.

- 조정자(reconciler)는 가상 DOM 트리를 비교하여 변경사항을 식별하고, 실제 DOM에 최소한의 업데이트를 적용하는 역할을 한다. 조정자는 랜더링 과정에서 중요한 역할을 하며, 성능 최적화에 기여한다.

- 렌더러(renderer)는 리액트의 다양한 플랫폼(웹, 네이티브 등)에서 UI를 렌더링하는 역할을 담당한다. 각 플랫폼에 맞는 렌더러가 존재하며, 리액트 코어와 상호작용하여 가상 DOM을 실제 UI로 변환한다. 예를 들어, ReactDOM은 웹용 렌더러이고, React Native는 모바일 앱용 렌더러이다.

- 이 2가지 개념은 리액트의 아키텍처에서 핵심적인 역할을 하며, 리액트가 다양한 환경에서 일관된 방식으로 UI를 렌더링할 수 있도록 돕는다.

### 9.2.1 애플리케이션이 처음 로드될 떄

- ReactDOM.createRoot(rootElement).render(<App />)와 같이 DOM에 노드를 지정하고 `render` 메서드를 호출하면, 리액트는 해당 컴포넌트를 초기 랜더링한다.

### 9.2.2 컴포넌트 내부 상탯값의 변경으로 인한 렌더링

- useState, useReducer 훅을 사용하여 상태를 변경하면, 해당 컴포넌트가 리랜더링된다. 상태 변경은 컴포넌트의 UI를 동적으로 업데이트하는 데 사용된다.

- forceUpdate 메서드를 호출하여 강제로 컴포넌트를 리랜더링할 수도 있다. 이 방법은 상태 변경 없이도 컴포넌트를 다시 렌더링해야 할 때 유용하다. 그러나 함수형 컴포넌트에서는 forceUpdate가 없으므로, 상태를 변경하는 방법을 사용해야 한다.

### 9.2.3 부모 컴포넌트의 렌더링으로 인한 자식 컴포넌트의 렌더링

- 부모 컴포넌트가 리랜더링되면, 자식 컴포넌트도 함께 리랜더링된다. 이는 부모 컴포넌트의 상태나 props가 변경될 때 발생한다.

### 9.2.4 컨텍스트 값의 변경으로 인한 렌더

- 컨텍스트(Context)는 리액트에서 전역적으로 데이터를 공유하는 방법이다. 컨텍스트 값이 변경되면, 해당 컨텍스트를 구독하고 있는 모든 컴포넌트가 리랜더링된다.

## 9.3 리랜더링에 대한 오해

- 리랜더링은 상태 변경, 부모 컴포넌트 리랜더링, 컨텍스트 변경 등 다양한 이유로 발생할 수 있다. 그렇기 때문에, 단순히 props 변경만이 리랜더링의 원인이 아니라는 점을 이해하는 것이 중요하다.

### 9.3.1 자식 컴포넌트와 props.children

- 부모 컴포넌트가 리랜더링되면, 자식 컴포넌트도 함께 리랜더링된다. 하지만 props.children으로 전달된 자식 엘리먼트가 변경되지 않았다면, 자식 컴포넌트는 이전 렌더링 결과를 재사용할 수 있다. 이는 리액트의 재조정 과정에서 이루어진다. 왜냐하면 리액트는 props.children의 참조가 동일한지 확인하여, 변경되지 않았다면 자식 컴포넌트를 재사용하기 때문이다.

### 9.3.2 컴포넌트에 전돨되는 props 값이 변경되었을 때?

- props값이 바뀐다는거는 부모 컴포넌트가 리랜더링되었다는 뜻이고, 따라서 자식 컴포넌트도 리랜더링된다. 다만, 자식 컴포넌트에 ref가 전달되는 경우에는 상황이 다를 수 있다. ref는 컴포넌트 인스턴스나 DOM 노드에 대한 참조를 제공하는데, ref가 변경되지 않았다면 자식 컴포넌트는 이전 렌더링 결과를 재사용할 수 있다.

## 9.4 리액트 랜더링 규칙

### 9.4.1 부수 효과 제거와 멱등성 보장

- 리액트 컴포넌트는 부수 효과를 제거하고 멱등성을 보장해야 한다. 이는 컴포넌트가 동일한 입력(props, state)으로 여러 번 호출되더라도 동일한 출력(UI)을 생성해야 한다는 의미이다. 부수 효과는 컴포넌트의 렌더링 과정에서 발생하는 외부 상태 변경을 의미하며, 이를 제거함으로써 컴포넌트의 예측 가능성과 안정성을 높일 수 있다.

- 또는 외부자원을 사용하면 안된다. 예를 들어, 컴포넌트 내부에서 전역 변수나 외부 API를 직접 호출하는 것은 부수 효과를 발생시킬 수 있다. 대신, 이러한 작업은 `useEffect` 훅과 같은 리액트의 생명주기 메서드를 사용하여 처리해야 한다.
  - 콘손로깅 : 외부 API 이지만 디버깅 용이기 떄문에 예외적으로 허용된다.
  - 쿠키/저장소 접근: 컴포넌트 내부에서 쿠키나 로컬 스토리지에 직접 접근하는 것은 저장소에 따라 달라지기 때문에 순수성이 깨진다.
  - 상태 업데이트: 컴포넌트 내부에서 상태를 직접 업데이트하는 것은 즉시 또 다른 리랜더링이 발생할 수 있다.
  - 네크워크 요청: 랜더링은 동기적으로 빠르게 완료되어야 하기 때문에, 랜더링 시점을 예측할 수 없게 된다.
  - 외부 변수 변경: 컴포넌트 외부 변수를 수정하는것은 다른 컴포넌트에 영향을 줄 수 있다.
  - 직접적인 DOM 조작: 컴포넌트 내부에서 직접 DOM을 조작하는 것은 리액트의 가상 DOM과 충돌할 수 있다.

### 9.4.2 JSX로 전달된 값의 불변성 유지

- JSX로 전달된 값은 불변성을 유지해야 한다. 이는 컴포넌트가 렌더링될 때 전달된 props나 state가 변경되지 않아야 한다는 의미이다.
- 예를 들어, 배열이나 객체를 props로 전달할 때는 새로운 참조를 생성하여 전달해야 한다. 이렇게 하면 리액트는 이전 값과 새로운 값을 비교하여 변경사항을 감지할 수 있다. 반면에, 기존 배열이나 객체를 직접 수정하는 것은 불변성을 깨뜨리므로 피해야 한다.
