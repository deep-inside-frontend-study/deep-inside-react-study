### 10장

- props 사용법, 검증에 대한 방식은 다들 알고 계실 것 같아 생략하겠습니다.
- 다양한 컴포넌트 패턴 방식이 흥미로웠습니다. 책에서도 4-5가지의 케이스가 나오는데요. 개인적으로 이 부분은 summary에 적은 것처럼 정답이 없는 문제라고 생각합니다.
- 반대로 저는 컴포넌트 개발 시에 **최소한의 원칙**을 정하고 컴포넌트를 개발하는 것 같습니다.
  - 예를 들어, Button 컴포넌트를 개발했다면 공통 스타일을 입히되, props로 기존 button 태그가 가지고 있는 타입을 확장시켜 만듭니다.
  - 이렇게 하는 이유는 사용자 입장에서 예측 가능하게 하는 목적입니다. 추가로 loading과 같은 props를 넣어 내부적으로 loading props를 보고 버튼을 disabled 처리하는 등의 세부 로직은 내부적으로 구현합니다. 내용물의 경우 기존 button 태그 처럼 chidlren 방식으로 받게 합니다.
  - 만약 Button이 특정 케이스에만 동작하거나, 특정 도메인에 종속된다 싶으면, 방금 만든 Button 컴포넌트를 바탕으로 새로운 버튼을 만듭니다. (ex) BottomSheetButton
  - 이런식으로 기본 컴포넌트는 최대한 수정 없이 만들고, 사용하는 측에서 그것을 확장시켜 새로 만들게 유도합니다. 즉, 공통적으로 합의된 기준을 높여 새 컴포넌트 개발 시간을 단축하고, 공통 컴포넌트를 최소한으로 건드리게 하여, 예측 불가능한 사이드 이펙트가 발생하는 것을 최소화하는 것이 목적입니다.
  - Button을 예시로 들었지만 Input, List, Modal 등에서도 적용 가능한 이야기일 것입니다. 다만 그것이 slot 패턴일 수도 있고, render props 방식일 수도 있고, 합성 방식일 수도 있습니다. 이건 컴포넌트 종류에 따라 다를 것입니다.
  - 결국 이것들은 개발 방법론이고, 가장 중요한 건 trade-off를 잘 구분하여 좋은 결과물을 만들어내는 역량이 아닐까 생각합니다.. (이게 어려워서 문제긴 합니다.)
  - [제가 했던 고민을 잘 설명한 링크가 있어서 공유 드립니다.](https://toss.tech/article/rethinking-design-system)

### 11장

- React의 배칭은 처음 공부하는 사람들이 헷갈리는 요소라고 생각합니다. React에 너무나 익숙해져서 당연히 배칭되는거 아냐? 라고 생각하지만, React를 처음 배웠을 때를 돌아보게 되었습니다. 이거 왜 이렇게 설계됐어? 라고 생각했지만 돌아보면 결국 성능적인 측면에서나 예측 가능한 측면에서 굉장히 효율적인 방법이라고 생각합니다.
- React18부터는 Automatic Batching을 통해서 setTimeout 내의 setState도 배칭 처리되는 것을 알 수 있습니다. 지난 주에도 말씀드린 것처럼 React도 지속적으로 예측 가능한 방향으로 개발되고 있다는 점을 느꼈습니다.
- setState 함수형 업데이트 부분은 최신 값을 참고한다는 것은 알았지만, 여전히 컴포넌트에서는 이전 스냅샷의 값을 참고한다는 점이 흥미로웠습니다. flushSync 함수도 사실 실무에서는 거의 쓰이지 않았지만, 해당 예시를 참고해서 좀 더 깊게 공부해 봐야겠습니다. 이 부분은 모임에서 나누면 좋겠습니다!

### 12장

- 이전 장에서 잠시 배웠던 파이버를 조금 더 깊게, 리액트의 렌더링과 같이 공부하며 이해가 쉽게 되었습니다. 확장된 지식을 바탕으로 공부하고 싶은 내용이 많아졌습니다.
- 개인적으로 예시에는 useState가 나왔지만 외부 시스템과 통신하는 일이 잦은 만큼 [이 훅](https://react.dev/reference/react/useSyncExternalStore)에 대해서도 책에 나온 지식을 적용해 보면 어떨까 싶습니다.
- 개인적으로 프론트엔드 개발자로서의 역량 중 하나는 사용자에게 부드러운 UI를 제공하는 것이라고 생각합니다. 리렌더링 횟수를 줄인다든지, 리플로우 비용을 줄인다는지 다양한 방면에서 최적화가 가능하겠지만 결국 리액트의 동시성이라는 하나의 카드도 잘 활용해야겠다고 생각합니다. 정확히 말하면 동시성을 활용해야만 하는 상황이 있습니다.
  - 예시를 들자면, 예전에 대시보드 LNB에서 드롭다운 메뉴를 사용한 적이 있습니다. 특정 드롭다운 메뉴를 클릭하면 해당 메뉴의 하위 드롭다운 리스트가 애니메이션을 통해 열리는 방식이었습니다. onClick 이벤트로는 active Key를 바꿔주는 핸들러를 달았습니다.
  - 그러던 중, 메뉴를 클릭한 경우 애니메이션이 약간 버벅이는 현상을 발견하였습니다.
  - 추측상, 메뉴를 클릭하게 되면 내부적으로 클릭된 menu를 찾고, 하위 메뉴가 열리는 애니메이션이 실행될 것인데, 이 작업들이 콜 스택을 짧게 점유하게 되고, 짧은 시간 내에 작업을 완료하지 못하기에 버벅이는 현상이 보였다고 생각합니다. 세부 로직은 라이브러리 내부에 구현되어 있어 제가 정확히 알 수 없었습니다.
  - 저는 active 상태를 다루는 변수에 useDefferedValue를 활용하여 우선순위를 낮췄고, 클릭 -> 메뉴가 클릭되어 하위 메뉴 열리는 애니메이션 실행됨 -> active가 true로 되어 해당 메뉴가 하이라이팅 되게 만드는 식으로 개별 동작의 수행 시간을 보장하는 방식으로 끊김 현상을 해결했습니다.
  - 개인적으로 사용자 경험에 가장 효과적인 방법은 위와 같이 동시성을 활용한 방법이라고 생각하게 되었습니다.

### 영상을 보고 느낀 점

- 결국 두 영상 모두 **좋은 코드**를 작성하는 방식에 대해 다루고 있습니다.
- 두 영상, 추가적으로 본 다른 영상들을 보고 제가 내린 결론은, 좋은 코드라고 불리기 위해 좋은 조건으로는
  - 하나의 컴포넌트는 하나의 역할만 하자. => DOM 구조가 달라져서 렌더링 방식이 달라지는 케이스를 지양하자. Suspense, ErrorBoundary, Wrapper 등을 활용하는 방식을 통해 하나의 역할에만 집중할 수 있게 하자.
  - 요구사항 변경 시 최소한의 변경으로 처리할 수 있게 하자. => 결국 공통 컴포넌트화를 잘 해야되는데 적어도 컴포넌트 내에서 도메인 분기는 하지 말아야 된다.
  - 한 눈에 들어와야 한다. => 작게는 변수명, 함수명을 잘 짓는 것을 시작으로 크게는 중요한 로직과 중요하지 않은 로직을 구분하고 사용자가 굳이 몰라도 되는 로직에 대해서는 함수 등을 만들어서 내부 로직으로 숨기는 게 낫다.
- 새로 잘 짜는 것도 좋지만 기존 코드를 잘 수정하는 것도 좋다고 생각합니다. 또한 평소에 좋은 습관을 들이는 것이 매우 중요하다고 생각했습니다.
