## 이번 주 핵심 요약

### 10장

- props는 리액트 컴포넌트가 데이터를 어떻게 받는지 보여주는 근간이다. state, 함수 등을 부모 -> 자식에게 넘겨주는 경우 props라고 부른다.
- props는 단방향으로 흐르는데, 위에서 설명했듯 부모 -> 자식 방향으로 흐른다. 여기서 좀 특이한 점은, props를 변경하는 것도 부모에서 주도권을 가지고 있다는 점이다. 즉, 데이터 수정 권한도 부모에서 변경 함수를 내려줘야 한다.
- 자식이 직접 props에 대한 소유권을 가지고 싶다면 직접 useState를 선언하고, 초기값으로 props를 주면 된다. 다만 이 방법은 그리 추천하지 않는다.
- props 또한 불변성을 지켜야 한다. 만약 이것을 지키지 않는다면? 값이 변경되어도 리렌더링이 되지 않을 것이다. 이 또한 리액트의 핵심 철학에 어긋나는 행위이므로 추천하지 않는다. 올바른 방식은 부모에서 전달받은 함수를 통해 update하는 것이다.
- React에서 <img> 태그의 HTML 엘리먼트 프롭스는 HTML 표준에 맞게 정의되어 있고, 당연하게 렌더링 과정에서 DOM 요소의 속성으로 변환된다. 즉, 우리는 자유롭게 props 이름과 타입을 정할 수 있지만 HTML 엘리먼트와 연결되는 부분들에서는 기존에 정의된 규칙을 지켜야 된다는 것이다.

- props 자료형 검증으로는 prop-types 라이브러리가 있고, 이전에는 react 패키지 안에 포함되어 있었다. 처음 React를 배울 때 자바스크립트로 배웠는데, 당시 잠시 사용했던 기억이 난다. 다만 react 패키지에서 외부 패키지로 분리되고, React19에서는 해당 기능을 제거(?)했다고 한다. (근데 위클리 다운로드 수가 4천만이 넘는다..?)
- 여튼, 우리는 대개 TypeScript를 쓰기 때문에 타입을 통해 props를 검증하면 된다.

- React 컴포넌트 패턴으로는 크게 합성, 상속 방식이 있다. 합성은 여러 작은 컴포넌트를 조힙하는 방식이고, 상속은 클래스 기반 컴포넌트에서 주로 사용되었다고 한다.
- children을 받는 방식, 고차 컴포넌트(HOC) 방식, render props 방식, slot props 방식, 컴파운트 컴포넌트 등이 소개되는데 각각의 차이 정도만 알면 좋다고 생각한다. 컴포넌트 설계에는 정답은 없고, 각각의 방식의 trade-off를 고려해야 된다고 생각한다. 정확히 말하면, 이러한 고민을 정말 깊게 하고 싶다면, 디자인 시스템을 다루는 팀을 따로 두는 게 옳다고 생각한다.

### 11장

- React에서 상태와 배칭을 공부하는 장이다. 사실, 배칭의 경우 React 개발자라면 처음에 헷갈릴 수 있는 지점이자 개인적으로 리액트의 핵심 컨셉 중 하나라고 생각한다.
- 우선 상태의 경우 지역 상태와 파생 상태로 나뉜다. 지역 상태는 쉽게 말하면, 우리가 컴포넌트 내에 선언한 local State라고 이해하면 된다. 즉, 접근 범위가 상태를 선언한 컴포넌트, props로 넘긴 경우 자식 컴포넌트로 한정된다. 파생 상태의 경우 또다른 useState 등을 선언하지 않고, 특정 state를 바탕으로 계산한 값이다. 파생 상태는 렌더링을 트리거할 순 없지만, 결국 state에 의존하기에 항상 업데이트된 state 기준으로 최신 상태를 유지할 수 있다. 개인적으로 파생상태를 이해하고 활용할 줄 아는 사람은 어느정도 리액트의 작동 원리를 이해한 사람이라고 생각한다.

- 상태는 스냅샷 형태로 저장된다. 즉, 상태 변화는 리렌더링을 트리거하지만, 결국 리렌더링이 된 후에야 업데이트된 상태값을 얻을 수 있다는 점이다.
- setState로 값을 바꾸고 다음 라인에 console.log를 찍어보면 값이 바뀌지 않은 것을 알 수 있다.
- 상태 업데이트 시에 함수형 업데이트 방식을 사용하면 최신 상태를 가져와 업데이트 할 수 있다. 반대로 말하면, 함수형 업데이트 방식을 채택하지 않는 경우 stale한 값을 바탕으로 업데이트한다. setCount(count + 1)을 4번 반복한다고 해서 count가 4만큼 커지지 않는다는 뜻이다. 우리는 상태 업데이트 시점을 정확히 알 수 없으므로 최신값 바탕으로 업데이트를 보장해야 한다면 함수형 업데이트 방식으로 해야 한다.
- 바인딩 내용은 앞 챕터에서 충분히 다뤄서 생략하겠습니다.

## 12장

- React18부터는 fiber 구조를 채택하였다. 기존 스택 재조정자에 비해 콜 스택을 계속 점유하지 않는다는 점이 핵심이라고 생각한다. 작업을 작은 단위로 잘라 콜 스택을 사용하는 방식을 활용하여 동시성 기능을 구현할 수 있었다. 즉, 우리는 렌더링 작업으로 인해 우리가 원하는 작업(입력, 클릭)이 무제한 지연되는 것을 해결했다.
- fiber는 연결리스트 구조를 사용하는데, 우선 자식을 찾고, 다음에 형제를 찾고, 없으면 부모로 돌아간다.
- 렌더링 작업 우선순위를 정하는 레인을 알게 되었다. 비트마스크를 통해 우선순위가 정해져있고 useTransition 등을 통해 우선순위를 낮출 수 있다. 실제로 테스트해보니, useTransition으로 감싸게 되면 리렌더링이 한번 더 일어나는 것을 확인했다.
- current 트리, WIP 트리, 총 2개의 트리를 통해 우리는 UI 업데이트가 완성된 후의 화면을 볼 수 있다.
