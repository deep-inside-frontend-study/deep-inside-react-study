# 이번 주 핵심 요약

# chapter 10. 리액트의 프롭스와 컴포넌트 패턴 돌아보기

## 10.1 리액트의 프롭스와 컴포넌트

- 프롭스는 데이터를 남기는 핵심 메커니즘이다. 특히 부모와 자식간에 불변성을 유지하면서 데이터를 전달하는 데 중요한데, 그 이유는 리액트가 컴포넌트의 상태를 관리하는 방식 때문이다. 프롭스는 컴포넌트가 자신의 상태를 변경하지 않고, 부모로부터 전달받은 데이터를 사용하여 렌더링할 수 있도록 도와준다.
- 컴포넌트 패턴은 리액트에서 컴포넌트를 구성하는 다양한 방법을 말하는데, 패턴들의 장단점을 알면. 컴포넌트를 더 효율적으로 설계할 수 있다. 예를 들어, 고차 컴포넌트(HOC)는 컴포넌트를 래핑하여 추가 기능을 제공하는 패턴으로, 코드 재사용성을 높이는 데 유용하다. 반면에 렌더 프로프(Render Props) 패턴은 컴포넌트가 렌더링할 때 함수를 전달하여 동적으로 UI를 구성하는 방법으로, 유연성을 제공하지만 복잡성을 증가시킬 수 있다.

## 10.2 리액트의 프롭스와 상태 개념

- 불변성을 유지하면 3가지의 장점있는데, 첫째는 데이터 흐름을 예측 가능하게 만들어준다. 둘째는 동작을 추적하기 쉬워진다. 셋째는 성능 최적화에 도움이 된다. 불변성을 유지하면 데이터가 변경될 때마다 새로운 객체가 생성되므로, 리액트는 변경된 부분만을 효율적으로 업데이트할 수 있다. 또한, 불변성을 유지하면 이전 상태와 현재 상태를 쉽게 비교할 수 있어 디버깅이 용이해진다.

- 프롭스의 속성은 DOM 요소의 속성과 유사하지만, 리액트에서는 프롭스가 컴포넌트의 속성으로 사용된다는 점에서 차이가 있다. 프롭스는 컴포넌트에 전달되는 데이터로, 컴포넌트가 렌더링될 때 사용된다. 반면에 DOM 요소의 속성은 HTML 요소에 직접 적용되는 속성으로, 브라우저가 해석하여 렌더링하는 데 사용된다. 예를 들어, `<button disabled>`는 HTML 요소의 속성이지만, `<MyButton disabled={true}>`는 리액트 컴포넌트의 프롭스이다.

## 10.3 프롭스 자료형 검증

- 2가지 방법이 있는데, 첫째는 PropTypes 라이브러리를 사용하는 방법이다. PropTypes는 리액트에서 프롭스의 자료형을 검증하는 데 사용되는 라이브러리로, 컴포넌트가 받는 프롭스의 타입을 정의할 수 있다. 예를 들어, `MyComponent.propTypes = { name: PropTypes.string.isRequired }`와 같이 사용하여 `name` 프롭스가 문자열이고 필수임을 명시할 수 있다. 둘째는 TypeScript를 사용하는 방법이다. TypeScript는 정적 타입 검사 기능을 제공하여, 컴포넌트의 프롭스에 대한 타입을 정의할 수 있다. 예를 들어, `interface MyComponentProps { name: string; }`와 같이 인터페이스를 정의하고, 컴포넌트에서 이를 사용하여 프롭스의 타입을 검증할 수 있다.

## 프롭스를 사용하는 컴포넌트 패턴

- 프롭스를 사용하는 컴포넌트 패턴에는 여러 가지가 있는데, 대표적으로 고차 컴포넌트(HOC), 렌더 프로프(Render Props) 등이 있다. 고차 컴포넌트는 컴포넌트를 래핑하여 추가 기능을 제공하는 패턴으로, 코드 재사용성을 높이는 데 유용하다. 렌더 프로프 패턴은 컴포넌트가 렌더링할 때 함수를 전달하여 동적으로 UI를 구성하는 방법으로, 유연성을 제공하지만 복잡성을 증가시킬 수 있다.

- 합성과 상속 패턴은 리액트에서 컴포넌트를 구성하는 두 가지 주요 패턴이다. 합성 패턴은 여러 컴포넌트를 조합하여 새로운 컴포넌트를 만드는 방법으로, 유연성과 재사용성을 높이는 데 유용하다. 반면에 상속 패턴은 기존 컴포넌트를 확장하여 새로운 컴포넌트를 만드는 방법으로, 코드 재사용성을 높이는 데 도움이 되지만, 복잡성을 증가시킬 수 있다. 리액트에서는 일반적으로 합성 패턴이 더 권장되는 방식이다.

- 고차 컴포넌트(HOC)는 컴포넌트를 래핑하여 추가 기능을 제공하는 패턴으로, 코드 재사용성을 높이는 데 유용하다. 예를 들어, `withLogging`이라는 HOC를 만들어서 컴포넌트가 렌더링될 때마다 로그를 출력하도록 할 수 있다. 렌더 프로프(Render Props) 패턴은 컴포넌트가 렌더링할 때 함수를 전달하여 동적으로 UI를 구성하는 방법으로, 유연성을 제공하지만 복잡성을 증가시킬 수 있다. 예를 들어, `DataFetcher`라는 컴포넌트가 데이터를 가져오는 함수를 렌더 프로프로 전달하여, 데이터를 가져온 후에 UI를 구성할 수 있다.

- 랜더 프롭스 패턴은 컴포넌트가 렌더링할 때 함수를 전달하여 동적으로 UI를 구성하는 방법으로, 유연성을 제공하지만 복잡성을 증가시킬 수 있다. 예를 들어, `DataFetcher`라는 컴포넌트가 데이터를 가져오는 함수를 렌더 프로프로 전달하여, 데이터를 가져온 후에 UI를 구성할 수 있다. 이 패턴은 컴포넌트 간의 코드 재사용성을 높이는 데 유용하지만, 컴포넌트 트리가 깊어질 수 있어 성능에 영향을 줄 수 있다.

- 슬롯 프롭스 패턴은 컴포넌트가 자식 컴포넌트를 렌더링할 때, 특정 위치에 자식 컴포넌트를 삽입할 수 있도록 하는 패턴이다. 예를 들어, `Modal` 컴포넌트가 있고, 이 컴포넌트는 `Header`, `Body`, `Footer`라는 슬롯 프롭스를 가지고 있다고 가정해보자. 사용자는 `Modal` 컴포넌트를 사용할 때, 각 슬롯에 원하는 내용을 전달하여 모달의 구조를 자유롭게 구성할 수 있다. 이 패턴은 컴포넌트의 유연성을 높이는 데 도움이 된다. 단, 컴포넌트의 구조가 복잡해질 수 있으므로, 유지보수 가능한 적절한 설계와 문서화가 필요하다.

- 컴파운트 컴포넌트 패턴은 여러 개의 컴포넌트를 하나의 컴포넌트로 묶어서 사용하는 패턴이다. 예를 들어, `Form` 컴포넌트가 있고, 이 컴포넌트는 `Form.Input`, `Form.Button`과 같은 하위 컴포넌트를 가지고 있다고 가정해보자. 사용자는 `Form` 컴포넌트를 사용할 때, 하위 컴포넌트를 통해 폼을 구성할 수 있다. 이 패턴은 컴포넌트의 구조를 명확하게 하고, 코드 재사용성을 높이는 데 도움이 된다. 단, 컴포넌트 간의 의존성이 높아질 수 있으므로, 적절한 설계와 문서화가 필요하다.

- 명시적 슬록 패턴 - slot type RFC는 컴포넌트가 자식 컴포넌트를 렌더링할 때, 특정 위치에 자식 컴포넌트를 삽입할 수 있도록 하는 패턴이다. 예를 들어, `Modal` 컴포넌트가 있고, 이 컴포넌트는 `Header`, `Body`, `Footer`라는 슬롯 프롭스를 가지고 있다고 가정해보자.

```JSX
import { createHost, createSlot } from 'create-slots'

const ModalHeader = createSlot('div')
const ModalBody = createSlot('div')
const ModalFooter = createSlot('div')

const Modal = ({ children }) => {
  return createHost(children, (Slots) => (
    <div className="modal-overlay">
      <div className="modal">
        <div className="modal-header">
          {Slots.get(ModalHeader)}
        </div>
        <div className="modal-body">
          {Slots.get(ModalBody)}
        </div>
        <div className="modal-footer">
          {Slots.get(ModalFooter)}
        </div>
      </div>
    </div>
  ))
}

Modal.Header = ModalHeader
Modal.Body = ModalBody
Modal.Footer = ModalFooter

```

# chapter 11. 리액트의 상태와 배칭 돌아보기

## 11.2 리액트의 상태 정의와 종류

- 리액트의 상태는 컴포넌트가 렌더링될 때 사용되는 데이터로, 컴포넌트의 동적인 부분을 관리하는 데 사용된다. 상태는 컴포넌트 내부에서 관리되며, 상태가 변경될 때마다 컴포넌트가 다시 렌더링된다. 리액트에서는 상태를 관리하기 위해 내부상태와 파생상태를 구분한다. 내부상태는 컴포넌트가 직접 관리하는 상태로, `useState` 훅을 사용하여 정의할 수 있다. 파생상태는 내부상태에서 계산된 상태로, `useMemo` 훅을 사용하여 정의할 수 있다.

- 상태 또한 불변성이 유지되어야 하는데, 그 이유는 리액트가 상태의 변경을 감지하여 컴포넌트를 다시 렌더링하는 방식 때문이다. Object.is()로 상태의 변경을 감지하기 때문에, 상태가 변경될 때마다 새로운 객체를 생성해야 한다. 만약 상태를 직접 변경하면, 리액트는 상태의 변경을 감지하지 못하여 컴포넌트가 다시 렌더링되지 않을 수 있다.

- 상태를 부모로 끌어올려서 관리하는 패턴을 "상태 끌어올리기"라고 한다. 이 패턴은 여러 컴포넌트가 공유하는 상태를 관리할 때 유용하다. 예를 들어, 두 개의 자식 컴포넌트가 동일한 상태를 필요로 하는 경우, 부모 컴포넌트에서 상태를 관리하고, 자식 컴포넌트에 프롭스로 전달하여 사용할 수 있다. 이렇게 하면 상태의 일관성을 유지할 수 있고, 컴포넌트 간의 데이터 흐름을 명확하게 할 수 있다.

## 11.3 컴포넌트 간의 데이터 흐름 돌아보기

- 단방향 데이터 및 바인딩 흐름은 리액트에서 데이터가 부모 컴포넌트에서 자식 컴포넌트로 흐르는 방식이다. 이 방식은 데이터의 흐름을 예측 가능하게 만들어주고, 컴포넌트 간의 의존성을 줄이는 데 도움이 된다. 또한 애플리케이션 구조의 모듈화를 통해 관심사 분리를 하여 불필요한 랜더링을 방지할 수 있다.

## 11.4 리액트 배칭 돌아보기

- 리액트 배칭은 여러 상태 업데이트를 하나의 배치로 묶어서 처리하는 메커니즘이다. 이를 통해 불필요한 렌더링을 방지하고, 성능을 최적화할 수 있다. 즉, setState()가 여러 번 호출되더라도, 리액트는 이를 하나의 배치로 묶어서 처리하여, 컴포넌트가 한 번만 렌더링되도록 한다.

- 리액트 배칭은 이벤트 핸들러, 라이프사이클 메서드, 그리고 `useEffect`와 같은 훅에서 자동으로 적용된다. 그러나, 17버전 이전에는 비동기 작업이나 타이머에서 상태 업데이트를 할 때는 배칭이 적용되지 않을 수 있다. 이 경우, `unstable_batchedUpdates` 함수를 사용하여 수동으로 배칭을 적용할 수 있었다. 하지만, 18버전부터는 모든 상태 업데이트에 대해 자동으로 배칭이 적용되도록 개선되었다.

- 동기적으로 상태를 업데이트 해야될때는 18버전 이후 부터는 `flushSync` 함수를 사용하여 상태 업데이트를 즉시 처리할 수 있다. 이 함수는 상태 업데이트를 동기적으로 처리하여, 컴포넌트가 즉시 렌더링되도록 한다. 예를 들어, `flushSync(() => { setState(newState); });`와 같이 사용하여 상태 업데이트를 동기적으로 처리할 수 있다.

# chapter 12. 리액트를 구성하는 뿌리 파이버 돌아보기

## 12.2 리액트 스택 재조정자 알아보기

- 리액트 스택 재조정자는 리액트가 컴포넌트를 렌더링할 때, 컴포넌트 트리를 구성하는 데 사용되는 알고리즘이다. 호출 스택을 사용하여 컴포넌트를 렌더링한다. 이 방식은 컴포넌트 트리를 효율적으로 구성할 수 있지만, 긴 컴포넌트 트리를 렌더링할 때는 호출 스택이 넘칠 수 있는 단점이 있다.

- 예들들어 setState()가 호출될 때, 리액트는 컴포넌트를 렌더링하기 위해 호출 스택을 사용하여 컴포넌트 트리를 구성한다. 이 과정에서, 컴포넌트가 렌더링될 때마다 호출 스택이 쌓이게 된다. 이러한 과정에 한계는 호출 스택은 기본적으로 동기적으로 작동하기 때문에, 긴 컴포넌트 트리를 렌더링할 때는 호출 스택이 넘칠 수 있다는 것이다. 이로 인해, 리액트는 긴 컴포넌트 트리를 렌더링할 때 성능 문제가 발생할 수 있다.

## 12.3 리액트 파이버 알아보기

- 리액트 파이버는 리액트 16에서 도입된 새로운 렌더링 엔진으로, 긴 컴포넌트 트리를 효율적으로 렌더링할 수 있도록 설계되었다. 파이버는 호출 스택 대신에 작업 큐를 사용하여 컴포넌트를 렌더링한다. 이를 통해, 긴 컴포넌트 트리를 렌더링할 때도 호출 스택이 넘치지 않도록 하여서 매끄럽게 렌더링할 수 있다. 또한, 파이버는 작업의 우선순위를 조정할 수 있는 기능을 제공하여, 사용자 인터랙션과 관련된 작업을 우선적으로 처리할 수 있도록 한다.

- 리액트 파이버는 작업 큐를 사용하여 컴포넌트를 렌더링하는데, 이 방식은 컴포넌트 트리를 효율적으로 구성할 수 있다. 그 덕분에 랜더링 작업의 우선순위를 조정할 수 있고, 긴 컴포넌트 트리를 렌더링할 때도 호출 스택이 넘치지 않도록 하여, 성능을 최적화할 수 있다.

- 파이버 노드를 해부해보면 파이버 재조정자는 콜 스택에 의존하는 대신 작업 큐를 사용하여 컴포넌트를 렌더링하는데, 이 방식은 컴포넌트 트리를 효율적으로 구성할 수 있다. 파이버 노드는 컴포넌트의 상태와 렌더링 정보를 담고 있는 객체로, 리액트가 컴포넌트를 렌더링할 때 사용된다. 파이버 노드는 컴포넌트의 상태, 프롭스, 그리고 자식 컴포넌트에 대한 정보를 포함하고 있다.

- 핵심 속성은 다음과 같다. `tag`는 파이버 종류를 나타내고 `type`은 컴포넌트의 유형을 나타내며, `key`는 컴포넌트를 식별하는 데 사용되는 고유한 값이다. `stateNode`는 컴포넌트의 실제 DOM 노드를 참조하는 속성으로, 리액트가 컴포넌트를 렌더링할 때 사용된다. `child`, `sibling`, `return`은 컴포넌트 트리를 구성하는 데 사용되는 속성으로, 각각 자식 컴포넌트, 형제 컴포넌트, 그리고 부모 컴포넌트를 참조한다.

- 데이터와 상태 관리에 관련된 속성으로는 `pendingProps`, `memoizedProps`, `updateQueue`, `memoizedState`가 있다. `pendingProps`는 컴포넌트가 다음 렌더링에서 사용할 프롭스를 나타내고, `memoizedProps`는 이전 렌더링에서 사용된 프롭스를 나타낸다. `updateQueue`는 컴포넌트의 상태 업데이트를 관리하는 큐로, 상태 업데이트가 발생할 때마다 이 큐에 추가된다. `memoizedState`는 이전 렌더링에서 사용된 상태를 나타내며, 리액트가 상태 변경을 감지하여 컴포넌트를 다시 렌더링할 때 사용된다.

- 부수 효과와 관련된 속성으로는 `flags`, `deletions`가 있다. `flags`는 컴포넌트에 적용된 부수 효과를 나타내고 `deletions`는 컴포넌트가 삭제될 때 발생하는 부수 효과를 관리하는 배열로, 컴포넌트가 삭제될 때 이 배열에 추가된다.

```
{
  type: 'div',
  key: null,
  stateNode: <div></div>,
  child: null,
  sibling: null,
  return: null,

  pendingProps: null,
  memoizedProps: null,
  updateQueue: null,
  memoizedState: null,

  flags: null,
  subtreeFlags: null,
  deletions: null,

  alternate: null,
}
```

- 더블 퍼버링은 작업이 완료된 후에, 작업 큐에서 다음 작업을 처리하기 전에, 현재 작업이 완료된 것을 확인하는 메커니즘이다. current와 workInProgress는 리액트가 컴포넌트를 렌더링할 때 사용하는 두 개의 파이버 트리를 나타내는 속성이다.
  current는 현재 렌더링된 컴포넌트 트리를 나타내고, workInProgress는 다음 렌더링에서 사용할 컴포넌트 트리를 나타낸다. 리액트는 작업이 완료된 후에, workInProgress 트리를 current 트리로 교체하여, 다음 렌더링에서 사용할 수 있도록 한다.

- 파이버 우선순위 시스템은 레인이라고 불리는 개념을 사용하여, 작업의 우선순위를 관리하는 시스템이다. 레인은 작업의 중요도에 따라 여러 개의 레인으로 나뉘며, 우선 순위가 높은 작업은 사용자 인터랙션과 관련된 작업으로, 즉시 처리되어야 하는 작업이다. 우선 순위가 낮은 작업은 데이터 페칭과 같은 작업으로, 사용자 인터랙션과 직접적으로 관련이 없는 작업이다.

- 파이퍼 트리 구조는 핵심은 재귀없이 가능한 트리 구조로, 컴포넌트 트리를 효율적으로 구성할 수 있다. `child`, `sibling`, `return` 속성을 사용하여 컴포넌트 트리를 구성하는데, `child`는 자식 컴포넌트를 참조하고, `sibling`은 형제 컴포넌트를 참조하며, `return`은 부모 컴포넌트를 참조한다. 이러한 구조로 각 파이버는 서로의 연결 포인터를 가지고 있다.

- 또 다른 핵심은 더블 버퍼링과 얼터네이트 포인터인데, 리액트는 작업이 완료된 후에, workInProgress 트리를 current 트리로 교체하여, 다음 렌더링에서 사용할 수 있도록 한다. 또한, 얼터네이트 포인터를 사용하여, 현재 렌더링된 컴포넌트 트리와 다음 렌더링에서 사용할 컴포넌트 트리를 양뱡으로 참조하여 작업이 완료된 후에, workInProgress 트리를 current 트리로 교체하는 메커니즘을 구현한다. 이러한 구조로 상태 업데이트가 발생하면 매번 새로운 트리를 생성하는 대신, 기존 트리를 재사용하여 효율적으로 렌더링할 수 있다.

- 파이버객체를 사용해서 동시성 기능 원리는 작업 큐를 사용하여 컴포넌트를 렌더링하는데, 하나의 while 반복문을 사용하여 작업 큐에서 작업을 처리한다.
  작업 내용을 노드 객체에 담아 관리하고 지금 처리해야 되는 작업을 가리키는 nextUnitOfWork 포인터를 사용하여 작업 큐에서 작업을 처리한다. 작업이 완료되면, 리액트는 다음 작업을 처리하기 위해 nextUnitOfWork 포인터를 업데이트하여, 다음 작업을 가리키도록 한다. 그리고 scheduleCallback 함수를 사용하여, 여유 있을때 다음 작업을 처리하도록 예약한다.

- Fiber 업데이트 요청 흐름: `setState()` 호출 → Update 객체 생성 → 해당 Fiber의 `updateQueue`에 추가 → `scheduleUpdateOnFiber()` 호출 (return 포인터를 따라 루트까지 올라가며 lane 마킹) → `ensureRootIsScheduled()` 호출. 이때 SyncLane이면 `scheduleMicrotask()`로 동기 처리하고, 그 외에는 `scheduleCallback()`으로 비동기 처리한다. `scheduleCallback`은 내부적으로 MessageChannel을 사용하여 브라우저에게 제어권을 양보하면서 작업을 예약한다.
