## 10. 리액트의 프롭스와 컴포넌트 패턴 돌아보기

### 리액트의 props
- 트리 구조를 이루며 구성 (단방향 데이터 흐름)
- 관리 주체는 부모 컴포넌트, 자식에서는 프롭스 변경 불가능
- 불변성 유지 필요
- JSX의 props는 컴파일 되면 React.createElement() 함수의 인자로 변환되어 프롭스 객체에 담김
  - 정해진 타입 규칙을 따라야함

### Props의 자료형 검증
- 부모와 자식 컴포넌트 간의 데이터 전달 통로이므로, props의 데이터 타입 일치가 중요

#### Props 자료형 검증 방법 2가지
- Prop-types 라이브러리
  - 터압 알차 여부 확인 후, 브라우저 콘솔에 경고 표시
  - 현재는 별도의 패키지로 분리되었고, 리액트 19버전부터는 아에 제거됨 (렌타임 체킹이 안됨)
- Typescript 사용하기
  - 정적으로 타입 검증

### 컴포넌트 패턴 (Props 활용)
- 컴포넌트 간 재사용은 **합성 모델**을 권장 (상속보다)
#### **합성**
- 여러개의 작은 컴포넌트를 조합하여 더 큰 컴포넌트를 만드는 방식
- 결합도를 낮추고, 독립성과 재사용성을 높임
- **포함** 패턴
  - 다른 컴포넌트를 품을 수 있는 컴포넌트 만드는 기법
  - children 프롭스를 통해 구현
#### **상속**
- 클래스 기반 객체지향 프로그래밍의 기반으로 자식 컴포넌트가 부모의 기능을 물려받아 확장하는 방식
- 부모와 자식 간의 강한 결합도, 유연성 해침

### 컴포넌트 재사용 / 유연성 높이는 방법
- children 프롭
- 슬롯 프롭스 (특정 영역 채워넣기 방식)
  - headerContent, footerContent처럼 API 명확하지만, 레이아웃이 부모 컴포넌트에 고정되어 유연성이 떨어짐
- 컴파운드 컴포넌트
  - Tabs.Tab 처럼 API가 선언적이고 유연하지만, 어떤 자식들이 허용하는지에 대한 계약이 암묵적이어서 잘못 사용 가능성 있음

#### 명시적 슬롯 개념에 대한 논의
- 컴파운트 컴포넌트의 선언적 API + 슬롯 props의 명시적 계약이라는 장점만 합치고 싶다!
- 의도에 맞는 컴포넌트 설계와 유연함을 모두 잡을 수 있을 것
  - 컴포넌트가 자신이 받을 수 있는 슬롯의 종류를 명시적으로 정의 + 유저는 그에 맞는 슬롯 전용 컴포넌트를 사용하여 내용 채우기 방식


## 11. 리액트의 상태와 배칭 돌아보기

### 리액트의 상태 종류
#### 지역 상태
- 컴포넌트 내부에 선언되어 다른 컴포넌트에서는 참조하지 못하는 내부 상태값
- Ex. useState
#### 파생 상태
- 다른 상태나 Props로부터 계산되어 파생된 값 (연산된 값)
- React애서는 해당 값을 리렌더링 시 계산 || useMemo()등을 통해 메모이제이션

### Stale Closure (오래된 클로저)
- 한번 렌더링이 진행되면, 해당 렌더링 내부에서 참조하는 상태값은 UI에 반영된 후 해당 렌더링 동안 고정
- 이벤트 핸들러나 비동기 콜백 함수가 특정 시점의 상탯값을 기억하여 오래된 상태값을 그대로 참조하는 현상 발생 가능
- **React는 객체의 참조를 비교하여 상태 변화 여부를 판단**

### 상태 끌어올리기 (Lifting State Up)
- 여러 컴포넌트가 동일한 상태를 공유하고 동기화해야할때, 그 상태를 가장 가까운 공통 조상 컴포넌트로 옮겨 관리
- 단방향 데이터 흐름을 준수하면서 컴포넌트 간에 상태를 공유하는 방법

### 배칭 (Batching)
- React의 성능 최적화 기법
- 여러개의 상태 업데이트를 하나의 묶음 (batch)로 만들어서 한번의 리렌더링만 수행하도록 하는 것
  - React는 같은 이벤트 처리 흐름 내에서 발생한 다수의 setState() 호출을 배치 처리하여 불필요한 중복 렌더링을 방지
  - 내부의 업데이트 큐에 요청을 쌓았다가, 이벤트 핸들러 실행이 끝난 이후 한번에 처리하여 단일 리렌더링을 수행하는 것!
- React 18부터는 ReactDOM.createRoot()를 사용해 렌더링시 **setTimeout(), Promose 콜백 등도 자동으로 배칭 처리됨!!**

### flushSync()
- 상태 업데이트를 즉시 DOM에 동기적으로 반영해야하는 경우 (드문 경우)
- 여러 상태 업데이트를 한번에 묶어서 렌더링하는게 X라, 특정 업데이트를 즉시 강제로 실행하여 DOM을 업데이트 하는것


## 12. 리액트를 구성하는 뿌리, 파이버 돌아보기
### 스택 재조정자 (React 15 이하 버전)
- 스택 재조정자는 컴포넌트 트리를 재귀적으로 순회하며, 모든 과정을 하나의 동기적인 작업으로 처리
- 렌더링이 한번 시작되면, 멈출 수가 없었음 (메인 스레드를 장시간 점유 -> 유저 인터렉션에 즉각적 반응이 어려웠음)

### 파이버 아키텍처 (React 16 이상 버전)
#### 파이버
- 실행 가능한 가장 작은 작업 단위
- 컴포넌트에 대한 정보를 담고 있는 JS 객체이자 처리해야할 하나의 작업 단위

#### 동작 원리
- 개발자는 렌더링에 우선순위를 부여하여 사용자 경험을 고려한 화면 제공이 가능
- 렌더링이라는 무거운 작업을 "fiber"라는 작은 단위로 분할 -> 각 단위를 처리 -> 메인 스레드에 제어권을 넘겨줄 지 결정 ->
- if) 할당된 시간 초과? -> 진행 중이던 렌더링 잠시 중지 후 브라우저에게 제어권 양보 -> 이후에 다시 작업 진행

#### 파이버 재조정자
- 스택이 아니라, 작업에 필요한 모든 정보를 파이버 객체에 담아 메모리에 유지
- 스택은 제어가 불가능 BUT 파이버 객체는 렌더링 작업 시작, 중단, 재개, 버리기가 모두 가능! (비동기 렌더링 가능)

#### 우선순위와 레인(Lanes) 모델
- **스택** : 줄이 1개라서 무조건 대기
- **레인 모델** : 다차선 항로와 같은 시스템
  - "긴급도"에 따라 각기 다른 우선순위인 레인을 할당
  - -> 메인 스레드 독점 현상 X이, 긴급한 작업이 먼저 처리 가능해짐
  
#### 파이버 트리 구조 : 재귀없는 순회
- 링크드 리스트와 유사항 포인터 구조를 가짐
- 각 파이버는 서로의 부모, 자식 파이버로의 연결 포인터를 가지고 있음

#### 더블 버퍼링 && 얼터네이트 포인터
- **문제 상황** : 리액트가 화면에 보이는 UI를 직접 변경하여 렌더링 작업을 하면, 유저는 깨진 UI를 보게 됨으로 이걸 방지하기 위함
- 2개의 파이버 트리 (Current, work-in-progress 트리)를 유지하고, 렌더링 작업 WIP에서 완료 후 끝나면 WIP을 current로 바꿔치기
  - current 트리 : 현재 화면에 보이는 UI 구성하는 트리
  - WIP 트리 : 상태 변경 후, 보이지 않는 곳에서 새로 렌더링 작업을 수행하는 트리
- **얼터네이트 포인터**
  - 각 current 노드와 복제된 WIP 노드를 서로 가리키게 하여, 정보에 접근하고 파이버 노드를 재활용