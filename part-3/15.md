# 15장 리액트 메모이제이션 돌아보기

> 이름:  
> 날짜:  
> 목표:  

## 장 요약
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

## 15.1 당신이 리액트 메모이제이션을 돌아봐야 하는 이유
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

## 15.2 memo( )를 사용한 렌더링 최적화
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.2.1 memo( ) 사용법
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.2.2 성급한 최적화의 함정
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.2.3 중첩 구조와 children 프롭스의 함정
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

## 15.3 useMemo( ) : 값 메모이제이션
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.3.1 useMemo( ) 내부 동작 들여다보기
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.3.2 useMemo( )를 활용한 연산 최적화 예제
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

## 15.4 useCallback( ) : 함수 메모이제이션
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.4.1 useCallback( )으로 커스텀 훅에 안정적인 콜백 전달하기
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.4.2 useCallback( )으로 프롭스 메모이제이션하기
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.4.3 useCallback( ) 활용 : 디바운스 올바르게 동작하게 하기
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

## 15.5 리액트 컴파일러를 이용한 자동 메모이제이션
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.5.1 수동 메모이제이션의 한계
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.5.2 컴파일러 개발의 역사
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.5.3 리액트 컴파일러의 역할과 기능
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.5.4 리액트 컴파일러의 원리 및 동작 방식
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.5.5 리액트 컴파일러의 수동 메모이제이션 대체 가능 여부
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

### 15.5.6 리액트 컴파일러 사용해보기
- 요약:  
- 인상 깊은 점:  
- 질문:  
- 실습/코드:  
- 레퍼런스:  

## 학습 마무리 | 핵심 키워드 리마인드
- 핵심 키워드:  
- 오늘의 한 줄:  
- 남은 질문:  
